<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>(Concept Review/Generative Models) Latent/Stable Diffusion Fully Explained, Part 4 | Kevin (Won June) Cho</title> <meta name="author" content="Kevin (Won June) Cho"> <meta name="description" content="Different interpretation of the training objective, explanation of training/sampling algorithm and mathematical comparison of DDIM and DDPM sampling methods."> <meta name="keywords" content="deep-learning, image-segmentation, python, pytorch"> <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css"> <link rel="canonical" href="https://chokevin8.github.io/blog/2023/stable-diffusion-part4/"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/native.css" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js"></script> <script src="/assets/js/dark_mode.js"></script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/">Kevin (Won June) Cho</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">About Me</a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">My Blog<span class="sr-only">(current)</span></a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">My Projects</a> </li> <li class="nav-item "> <a class="nav-link" href="/repositories/">My Github</a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">My Resume</a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fas fa-moon"></i> <i class="fas fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5"> <div class="post"> <header class="post-header"> <h1 class="post-title">(Concept Review/Generative Models) Latent/Stable Diffusion Fully Explained, Part 4</h1> <p class="post-meta">September 10, 2023</p> <p class="post-tags"> <a href="/blog/2023"> <i class="fas fa-calendar fa-sm"></i> 2023 </a>   ·   <a href="/blog/tag/concept-review"> <i class="fas fa-hashtag fa-sm"></i> concept-review</a>   <a href="/blog/tag/generative-model"> <i class="fas fa-hashtag fa-sm"></i> generative-model</a>     ·   <a href="/blog/category/posts"> <i class="fas fa-tag fa-sm"></i> posts</a>   </p> </header> <article class="post-content"> <hr> <h2 id="table-of-contents"><strong>Table of Contents:</strong></h2> <h3 id="latentstable-diffusion-fully-explained-part-1"><a href="/blog/2023/stable-diffusion/">Latent/Stable Diffusion Fully Explained! (Part 1)</a></h3> <ul> <li> <h3 id="introduction">Introduction</h3> </li> <li> <h3 id="stable-diffusion-vs-gan">Stable Diffusion vs GAN</h3> </li> </ul> <h3 id="latentstable-diffusion-fully-explained-part-2"><a href="/blog/2023/stable-diffusion-part2/">Latent/Stable Diffusion Fully Explained! (Part 2)</a></h3> <ul> <li> <h3 id="motivation">Motivation</h3> </li> <li> <h3 id="model-architecture">Model Architecture</h3> </li> <li> <h3 id="experiments--results">Experiments &amp; Results</h3> </li> </ul> <h3 id="latentstable-diffusion-fully-explained-part-3"><a href="/blog/2023/stable-diffusion-part3/">Latent/Stable Diffusion Fully Explained! (Part 3)</a></h3> <ul> <li> <h3 id="vaes-and-elbo">VAEs and ELBO</h3> </li> <li> <h3 id="model-objective">Model Objective</h3> </li> </ul> <h3 id="latentstable-diffusion-fully-explained-part-4-this-blog"> <a href="#stable-diffusion-in-numbers-2">Latent/Stable Diffusion Fully Explained! (Part 4)</a> (This Blog!)</h3> <ul> <li> <h3 id="different-view-on-model-objective"><a href="#model-objective2">Different View on Model Objective</a></h3> </li> <li> <h3 id="training-and-inference-ddim-vs-ddpm"><a href="#training-inference">Training and Inference (DDIM vs DDPM)</a></h3> </li> </ul> <h3 id="latentstable-diffusion-fully-explained-part-5--coming-soon"><a href="/blog/2023/stable-diffusion-part5/">Latent/Stable Diffusion Fully Explained! (Part 5- Coming Soon!)</a></h3> <ul> <li> <h3 id="conditioning">Conditioning</h3> </li> <li> <h3 id="classifier-free-guidance">Classifier-Free Guidance</h3> </li> <li> <h3 id="summary">Summary</h3> </li> </ul> <hr> <p><em>Note: For other parts, please click the link above in the table of contents.</em></p> <p><a id="stable-diffusion-in-numbers-2"></a></p> <h2 id="stable-diffusion-in-numbers-continued"><strong>Stable Diffusion In Numbers Continued</strong></h2> <p><a id="#model-objective2"></a></p> <h3 id="different-view-on-model-objective-1"><strong>Different View on Model Objective</strong></h3> <p>In this last part of the blog, I want to cover the mathematical details of conditioning and also classifier-free guidance. Before, that let’s briefly look at the algorithms for training and inference, and view the training objective we derived in a different way.</p> <p>Recall equation #17 from the previous part of the blog, or the final training objective of our LDM:</p> <p> $$\mathop{\arg \min}\limits_{\theta} \quad \frac{1}{2{\sigma_q}^{2}(t)} \frac{\hat{\alpha}_{t-1}(1-\alpha_t)^{2}}{(1-\hat{\alpha_t)^{2}}} [{||(\hat{x}_{\theta}(x_t,t)-x_0)||}^{2}] $$ </p> <p>Comparing this to equation #1 in the paper which describes the training objective, we can see that it is a bit different, as our equation above has some extra terms and is a MSE between predicted and ground truth original image, not noise as seen below.</p> <p><em>Equation #1 (Training objective) in the paper:</em></p> <p> $$L_{LDM} = ||\epsilon - \epsilon_{\theta}(x_t,t)||^2$$ </p> <p>So how are these <em>two somehow equivalent</em>? Well, let’s interpret our training objective in a different way and we’ll see how these two are connected. Recall equation #5 from the last blog (noted as equation #1 below), or the reparametrization trick we used for forward diffusion \(q(x_t \mid x_0)\) to calculate \(x_t\) in terms of the \(\hat{\alpha}\)s. Let’s rearrange this equation in terms of \(x_0\) instead!</p> <p> $$ x_t = \sqrt{\hat{\alpha}_t}x_0 + \sqrt{1-\hat{\alpha}_t}{\epsilon}_0 \quad (1)$$ $$ x_0 = \frac{x_t - \sqrt{1-\hat{\alpha}_t}{\epsilon}_0}{\sqrt{\hat{\alpha}_t}} \quad (1)$$ </p> <p>Then, recall the equation (equation #2 below) we derived for the mean of the ground truth denoising transition step distribution \(q(x_{t-1} \mid x_t,x_0)\), as we calculated this to minimize the KL-divergence of the ground truth and desired approximate transition step distribution to derive our training objective:</p> \[\mu_q = \frac{\sqrt{\alpha_t}(1-\hat{\alpha}_{t-1})x_t + \sqrt{\hat{\alpha}_{t-1}}(1-\alpha_t)x_0}{1-\hat{\alpha_t}} \quad (2)\] <p>Now, plug equation #1 in to \(x_0\) of equation #2 above:</p> <p> $$\mu_q = \frac{\sqrt{\alpha_t}(1-\hat{\alpha}_{t-1})x_t + \sqrt{\hat{\alpha}_{t-1}}(1-\alpha_t)\frac{x_t - \sqrt{1-\hat{\alpha}_t}{\epsilon}_0}{\sqrt{\hat{\alpha}_t}}}{1-\hat{\alpha_t}} \quad (2)$$ </p> <p>Skipping the rearranging algebra (you can try this yourself if you want to), we end up with:</p> <p> $$\mu_q = \frac{1}{\sqrt{\alpha_t}}x_t - \frac{\sqrt{1-\alpha_t}}{\sqrt{1-\hat{\alpha_t}}\sqrt{\alpha_t}}{\epsilon}_0 \quad (3)$$ </p> <p>Then, like before, to find the mean of the desired approximate denoising transition distribution \(\mu_{\theta}\), we simply replace the ground truth noise \({\epsilon}_0\) (since we don’t know ground truth distribution!) with a neural network that parametrizes \(\hat{\epsilon}_{\theta}(x_t,t)\) to predict \(\epsilon_0\) as accurately as possible to make our approximate denoising step as similar to the ground truth denoising step as possible:</p> <p> $$\mu_{\theta} = \frac{1}{\sqrt{\alpha_t}}x_t - \frac{\sqrt{1-\alpha_t}}{\sqrt{1-\hat{\alpha_t}}\sqrt{\alpha_t}}\hat{\epsilon}_{\theta}(x_t,t) \quad (4)$$ </p> <p>Now that equations #3 and #4 above both tell us the mean of both distributions, like what we did before, we find the KL divergence between the two. Recall the equation for calculating the KL-divergence between two Gaussians, and plug in to find the “new” training objective:</p> <p> $$ D_{KL}(\mathcal{N}(x;\mu_x,\Sigma_x) || \mathcal{N}(y;\mu_y,\Sigma_y)) = \frac{1}{2} [ \log \frac{\Sigma_y}{\Sigma_x} - d + tr({\Sigma_y}^{-1}\Sigma_x) + (\mu_y - \mu_x) ^ {T} {\Sigma_y}^{-1} (\mu_y - \mu_x) ] $$ </p> <p>Skipping the rearranging algebra again, we end up with our “new”, different interpretation of our training objective:</p> <p> $$\mathop{\arg \min}\limits_{\theta} \quad \frac{1}{2{\sigma_q}^{2}(t)} \frac{(1-\alpha_t)^{2}}{(1-\hat{\alpha_t})\alpha_t}[{||\epsilon_0 - \hat{\epsilon}_{\theta}(x_t,t)||}^{2}] \quad (5)$$ </p> <p>Equation #5 above is our “new” training objective, instead of predicting ground truth image, we predict the ground truth noise instead here. Empirically, depending on the use case, it may work better to predict the noise instead of the image and vice versa, and it seems like the authors of the paper decided to predict the noise. Note that the objective function finalizes to equation #6 below because it was empirically proven that getting rid of the coefficient in front of the MSE term actually performed better when evaluating the performance of diffusion models. This final objective function below (equation #6) is equivalent to the loss function the authors use, which we already saw above:</p> <p> $$L_{LDM} = ||\epsilon_0 - \epsilon_{\theta}(x_t,t)||^2 \quad (6)$$ </p> <p>Therefore, we simply end up with the mean squared error (MSE) between the ground truth noise \(\epsilon_0\) and the predicted noise \(\epsilon_{\theta}(x_t,t)\). Simply put, the decoder \(\hat{\epsilon}_{\theta}(x_t,t)\) (which is the U-Net) learns to predict the ground truth source noise \(\epsilon_0\) that is randomly sampled from \(\mathcal{N}(0, 1)\). The predicted source noise is the noise that originally brought the original image \(x_0\) to the pure noised (image) \(x_t\) via forward diffusion. As stated in the paper, this can also be seen as a sequence of \(T\) equally weighted autoencoders from \(t = 1,2....t-1,T\) which predicts a denoised variant of their input \(x_t\) in a Markovian fashion. As timestep reaches T, this Markovian process will then slowly converge to the ground truth input image \(x_0\), assuming the training of the decoder went well.</p> <p><a id="training-inference"></a></p> <h3 id="training-and-inference-ddim-vs-ddpm-1"><strong><em>Training and Inference (DDIM vs DDPM):</em></strong></h3> <p>Now that we’ve derived the training (loss) objective from scratch, let’s briefly go over the entire training and the inference algorithm:</p> <p><img src="/assets/images/train_inference_algorithm.png" width="985" height="250" class="center"></p> <figcaption>The training and inference algorithm, summarized.</figcaption> <p><br> Let’s first look at the training algorithm:</p> <ol> <li>We repeat the below process (steps 2~5) until convergence or a preset number of epochs.</li> <li>Sample an image \(x_0\) from our dataset/data distribution, \(q(x_0)\).</li> <li>Sample t, or timestep from 1 to \(T\).</li> <li>Sample noise from a normal distribution \(\epsilon \sim \mathcal{N}(0, I)\)</li> <li>Take gradient descent step on the training objective we just derived \(L_{LDM} = ||\epsilon - \epsilon_{\theta}(x_t,t)||^2\) with respect to \(\theta\), which is the parameters of the weights and biases of the decoder.</li> </ol> <p>Not too bad! What about the above sampling algorithm?</p> <p>Before describing the sampling process, let’s look back at the training objective, specifically regarding the value of T, or the timesteps for the forward process. Above, we described this as a Markovian process, and ideally we would like to <em>maximize</em> \(T\) or the number of timesteps in the forward diffusion so that the reverse process can be as close to a Gaussian as possible so that the generative process is accurate and generates a good image quality.</p> <p>However, in this Markovian sampling process called DDPM (short for Denoising Diffusion Probabilistic Models), the \(T\) timesteps have to be performed sequentially, meaning sampling speed is extremely slow, especially compared to fast sampling speeds of predecessors such as GANs. The limitation here is that the forward \(T\) steps and the reverse sampling \(T\) steps must be equal, as we are reversing the forward process for sampling. The above Markovian sampling algorithm is the DDPM sampling algorithm, which will be explained first, but then we will also mention a new, non-Markovian sampling process called DDIM (short for Denoising Diffusion Implicit Models) that is able to accelerate sampling speeds. <strong>Note that the authors of the LDM paper utilized DDIM because of this exact reason.</strong></p> <p>Remember that for sampling, we only need the trained decoder from above (no encoder). Therefore, we sample latent noise \(x_T\) from prior \(p(x_T)\), which is \(\epsilon \sim \mathcal{N}(0, I)\) and then run the series of \(T\) equally weighted autoencoders as mentioned before in a Markovian style. The equation shown in the sampling algorithm is essentially identical to equation #4 above, or:</p> <p> $$ \mu_{\theta} = \frac{1}{\sqrt{\alpha_t}}x_t - \frac{\sqrt{1-\alpha_t}}{\sqrt{1-\hat{\alpha_t}}\sqrt{\alpha_t}}\hat{\epsilon}_{\theta}(x_t,t) $$ </p> <p>The equation in the sampling algorithm at step #4 above just has an additional noise term \(\sigma_tz\) since the reparametrization trick \(x = \mu + \sigma_tz\). Note that in sampling, assuming our training went well, we have our trained neural network \(\hat{\epsilon}_{\theta}(x_t,t)\) that predicts the noise \(\epsilon\) for given input image \(x_t\) (remember that this neural network in our LDM is our U-Net architecture with the (cross) attention layers that predicts the noise given our input image). Then, inputting a timestep \(t\) and original image \(x_t\) to the trained neural network gives us the predicted noise \(\epsilon\), and using that we can sample \(x_{t-1}\) until \(t=1\). When \(t=1\), we have our sampled output of \(x_0\).</p> <p>Let’s summarize this sampling algorithm:</p> <ol> <li>First sample Gaussian noise \(x_T\) from normal distribution.</li> <li>Then, reverse the timesteps for the forward diffusion, and for each timestep, sample noise \(z\) from another independent normal distribution. Note that when \(t=1\), we don’t want to further add noise. Lastly, for each timestep, sample \(x_{t-1}\) according to above equation.</li> <li>Repeat step #2 for each timestep until \(t=1\), and the generated sample is the desired \(x_0\).</li> </ol> <p>However, as discussed above, Denoising Diffusion Implicit Model (DDIM) uses a non-Markovian sampling process that makes the process much quicker. DDPMs use a sampling process that is essentially the reverse of the forward diffusion (\(T\) forward and backward timesteps), while DDIM uses \(S\) steps instead of \(T\) where \(S&lt;T\), by using the fact that the forward diffusion process can be made non-Markovian and therefore the reverse sampling process can also be made non-Markovian. Therefore, the authors of the LDM paper use <em>DDIM over DDPM.</em></p> <p>Recall the forward diffusion process mentioned in the previous part of the blog: \(x_t = \mathcal{N}(x_t; \mu_t = \sqrt{1-\beta_t}x_{t-1},\Sigma_t = \beta_tI)\). This is essentially the forward process of DDPMs, which we can see that the process is Markovian, as \(x_t\) only depends on \(x_{t-1}\). However, in the previous part of the blog, we’ve already shown the forward process that can be made non-Markovian when we were deriving the training objective. Recall the Baye’s rule we used to derive the mean and variance of the approximate denoising step: \(q(x_{t-1}|x_t,x_0) = \frac{q(x_t|x_{t-1},x_0)q(x_{t-1}|x_0)}{q(x_t|x_0)}\). Note by rearranging the above equation for the forward diffusion step \(q(x_t|x_{t-1},x_0)\) we see that the forward step is no longer Markovian, and this is the forward step for DDIM: \(q(x_t|x_{t-1},x_0) = \frac{q(x_{t-1}|x_t,x_0)q(x_t|x_0)}{q(x_{t-1}|x_0)}\)</p> <p>With this non-Markovian forward diffusion step, the DDIM sampling process is also no longer forced to have the same number of timesteps \(T\). But how do we derive the DDIM sampling process? To derive the DDIM sampling process, we utilize the <em>reparametrization trick</em> again, which we applied previously for forward diffusion. We can use \(x = \mu + \sigma * \epsilon\) to essentially alter our sampling process \(q(x_{t-1}|x_t,x_0)\) to be parametrized by another random variable, a desired standard deviation \(\sigma_t\) (square this for variance). The reparametrization is shown below:</p> <p> $$\text{Recall equation #1:} \text{ } x_t = \sqrt{\hat{\alpha}_t}x_0 + \sqrt{1-\hat{\alpha}_t}{\epsilon}_0 $$ $$\text{The equation for} \text{ } x_{t-1} \text{ } \text{instead is:} \text{ } x_{t-1} = \sqrt{\hat{\alpha}_{t-1}}x_0 + \sqrt{1-\hat{\alpha}_{t-1}}{\epsilon}_{t-1} $$ $$\text{Add extra term} \text{ } \sigma_t \epsilon \text{ } \text{for reparametrization trick, where} \text{ } \sigma_t^{2} \text{ } \text{is the variance of our distribution.}$$ $$ x_{t-1} = \sqrt{\hat{\alpha}_{t-1}}x_0 + \sqrt{1-\hat{\alpha}_{t-1}-\sigma_t^{2}}\epsilon_t + \sigma_t \epsilon $$ $$\text{Since} \text{ } \epsilon_t = \frac{x_t - \sqrt{\hat{\alpha_t}}x_0}{\sqrt{1-\hat{\alpha_t}}}: \text{ } x_{t-1} = \sqrt{\hat{\alpha}_{t-1}}x_0 + \sqrt{1-\hat{\alpha}_{t-1}-\sigma_t^{2}}\frac{x_t - \sqrt{\hat{\alpha_t}}x_0}{\sqrt{1-\hat{\alpha_t}}} + \sigma_t \epsilon $$ $$\text{Therefore,} \text{ } q(x_{t-1}|x_t,x_0) = \mathcal{N}(x_{t-1};\mu_{t-1} = \sqrt{1-\hat{\alpha}_{t-1}-\sigma_t^{2}}\frac{x_t - \sqrt{\hat{\alpha_t}}x_0}{\sqrt{1-\hat{\alpha_t}}},\Sigma_{t-1}= \sigma_t^{2}I)) $$ $$\text{Recall equation #15 from last blog for variance formulation:} $$ $$q(x_{t-1} \mid x_t,x_0) \sim \mathcal{N}(x_{t-1}; \mu_t = \frac{\sqrt{\alpha_t}(1-\hat{\alpha}_{t-1})x_t + \sqrt{\hat{\alpha}_{t-1}}(1-\alpha_t)x_0}{1-\hat{\alpha_t}},\Sigma_t = \frac{(1-\alpha_t)(1-\hat{\alpha}_{t-1})}{(1-\hat{\alpha_t})}I)$$ $$\text{Then, also recall that} \text{ } \beta_t = 1-\alpha_t \text{ ,} \text{ } \text{therefore our new variance:}$$ $$\hat{\beta_t} = \sigma_t^{2} = \frac{1-\hat{\alpha}_{t-1}}{1-\hat{\alpha_t}} * \beta_t $$ </p> <p>Above shows the mean and the variance of the DDIM denoising step. With above result, we can now let \(\eta = \frac{1-\hat{\alpha}_{t-1}}{1-\hat{\alpha_t}}\) and now \(\sigma_t^{2} = \eta * \hat{\beta_t}\) where \(\eta\) can now be used to control the stochasticity/determinism of the sampling process. As one can see, if \(\eta = 0\), this means that the variance of the above denoising step becomes zero and therefore the sampling becomes deterministic. This means that given an input image, no matter how many different times you sampled, you would end up with similar images with the same high-level features! Therefore, this is why this process is called “denoising diffusion implicit model”, as like other implicit models like GANs, the sampling process is deterministic.</p> <p><strong>But our main point was that DDIM dramatically speeds up the sampling process. We’ve shown that the forward process is non-Markovian, but how do we show that the reverse process requires fewer steps as well?</strong> Recall the derived sampling process from above:</p> <p> $$x_{t-1} = \sqrt{\hat{\alpha}_{t-1}}x_0 + \sqrt{1-\hat{\alpha}_{t-1}-\sigma_t^{2}}\frac{x_t - \sqrt{\hat{\alpha_t}}x_0}{\sqrt{1-\hat{\alpha_t}}} + \sigma_t \epsilon $$ </p> <p>We will now aim to parametrize this sampling process for \(x_{t-1}\) in terms of our trained model. Here, we can see that given \(x_t\), we first make a prediction of \(x_0\), and then use both to make the prediction for \(x_{t-1}\). Now, recall the previously mentioned forward process \(q(x_t|x_0) = \mathcal{N}(x_t; \mu_t = \sqrt{\hat{\alpha}_t}x_0,\Sigma_t = (1-\hat{\alpha}_t)I)\). With reparametrization trick, we already showed that this gives our forward process to find \(x_t\) given \(x_0\) and our Gaussian noise \(\epsilon\): \(x_t = \sqrt{\hat{\alpha}_t}x_0 + \sqrt{1-\hat{\alpha}_t}{\epsilon}\). Rearranging the equation for \(x_0\) gives: \(x_0 = \frac{x_t - \sqrt{1-\hat{\alpha}_t}{\epsilon}}{\sqrt{\hat{\alpha}_t}}\). Now, here’s the important part, where do we utilize our trained model if this is the generative process? Recall from above again that <strong>our trained model \(\hat{\epsilon}_{\theta}(x_t,t)\) predicts noise \(\epsilon\) given \(x_t\) and timestep \(t\).</strong> Therefore, we rewrite the equation for \(x_0\) as:</p> <p> $$x_0 = \frac{x_t - \sqrt{1-\hat{\alpha}_t}\hat{\epsilon}_{\theta}(x_t,t)}{\sqrt{\hat{\alpha}_t}}$$ </p> <p>Therefore, when we plug in this equation for \(x_0\) in original sampling process equation, we get:</p> <p> $$x_{t-1} = \sqrt{\hat{\alpha}_{t-1}}\frac{x_t - \sqrt{1-\hat{\alpha}_t}\hat{\epsilon}_{\theta}(x_t,t)}{\sqrt{\hat{\alpha}_t}} + \sqrt{1-\hat{\alpha}_{t-1}-\sigma_t^{2}}\frac{x_t - \sqrt{\hat{\alpha_t}}x_0}{\sqrt{1-\hat{\alpha_t}}} + \sigma_t \epsilon $$. </p> <p>But recall that when we rearrange the same equation \(x_t = \sqrt{\hat{\alpha}_t}x_0 + \sqrt{1-\hat{\alpha}_t}{\epsilon}\) in terms of \(\epsilon\), we get \(\epsilon = \frac{x_t - \sqrt{\hat{\alpha_t}}x_0}{\sqrt{1-\hat{\alpha_t}}}\). Therefore, we replace that term above with our trained model as well, giving us the final equation for \(x_{t-1}\) for DDIM sampling:</p> <p> $$x_{t-1} = \sqrt{\hat{\alpha}_{t-1}}\frac{x_t - \sqrt{1-\hat{\alpha}_t}\hat{\epsilon}_{\theta}(x_t,t)}{\sqrt{\hat{\alpha}_t}} + \sqrt{1-\hat{\alpha}_{t-1}-\sigma_t^{2}}\hat{\epsilon}_{\theta}(x_t,t) + \sigma_t \epsilon_t $$. $$\text{where: }q(x_{t-1} \mid x_t,x_0) \sim \mathcal{N}(x_{t-1}; \mu_t = \frac{\sqrt{\alpha_t}(1-\hat{\alpha}_{t-1})x_t + \sqrt{\hat{\alpha}_{t-1}}(1-\alpha_t)x_0}{1-\hat{\alpha_t}},\Sigma_t = \frac{(1-\alpha_t)(1-\hat{\alpha}_{t-1})}{(1-\hat{\alpha_t})}I)$$ </p> <p>The above equation is the final equation that allows us to sample \(x_{t-1}\) from given \(x_t\) using our trained model. Suppose the forward process is non-Markovian now, and instead of having all of the Markovian steps from \(x_{1:T}\), we have a subset of \(S\) timesteps \({x_{\tau 1},....x_{\tau S}}\) where \(\tau\) is simply increasing sequence of \(S\) timesteps. Look at the figure below:</p> <p><img src="/assets/images/ddim-sampling.png" width="731" height="227" class="center"></p> <figcaption>Diagram showing DDIM forward and sampling process in comparison to DDIM.</figcaption> <p><br></p> <p>The diagram above is a simplified one in that \(\tau = [1,3]\), and the forward DDIM process \(q(x_3 \mid x_1,x_0)\) can be simply reversed by sampling using the above derived sampling process. <strong>Therefore, we see that DDIM utilizes a non-Markovian forward process that uses less timesteps which in turn allows it to use less computations in the reverse step as well.</strong></p> <p> $$x_{t-1} = \sqrt{\hat{\alpha}_{t-1}}\frac{x_t - \sqrt{1-\hat{\alpha}_t}\hat{\epsilon}_{\theta}(x_t,t)}{\sqrt{\hat{\alpha}_t}} + \sqrt{1-\hat{\alpha}_{t-1}-\sigma_t^{2}}\hat{\epsilon}_{\theta}(x_t,t) + \sigma_t \epsilon_t $$. </p> <p>Now, let’s look back at each term of the right hand side of the above equation, the first term is the predicted \(x_0\) given \(x_t\). The second term can be interpreted as the direction pointing to \(x_t\), and the third term is random noise sampled from a normal distribution. With the above equation, we have two special cases depending on the value of \(\sigma_t\). First, when \(\sigma_t = \sqrt{\frac{1-\hat{\alpha}_{t-1}}{1-\hat{\alpha}_t}} \sqrt{\frac{1-\hat{\alpha}_t}{\hat{\alpha}_{t-1}}}\), the forward diffusion process actually becomes Markovian, which means that the sampling process naturally becomes DDPM as well. Second, like when \(\eta=0\) above, we see that when \(\sigma_t = 0\) for all timestep, we see that there is no stochasticity as there is no random noise added. With the exception for when \(t=1\), we see that the process is deterministic and therefore this is why samples generated are nearly identical or share the same high level features.</p> <p>Lastly, another important note to make is that with the above equation, we can see that with the same trained model \(\hat{\epsilon}_{\theta}(x_t,t)\), we can have two different sampling methods DDPM and DDIM, with DDIM usually being superior over DDPM. Therefore, with DDIM, we do not need to retrain the model, which gives us another reason to use DDIM over DDPM.</p> <p>To wrap up, the main advantages of DDIM over DDPM are:</p> <ol> <li> <strong>Faster sampling</strong>: As mentioned above, DDIM is a non-Markovian process that enables sample generation with a much smaller timestep \(S\), where \(S&lt;T\) when \(T\) is the timestep required for DDPM. When the sampling trajectory \(S\) is much smaller than \(T\), we experience more computational efficiency at some cost of image generation quality.</li> <li> <strong>Control of stochasticity</strong>: As mentioned above, when \(\eta=0\) or \(\sigma_t=0\) for all timesteps, DDIMs are deterministic, meaning that if we start with the same latent vector (predicted noise) \(x_T\) via same random seed during sampling, the samples generated will all have the same high-level features.</li> <li> <strong>Allows interpolation</strong>: In DDPMs, interpolation is still possible, but the interpolation will not be accurate due to the stochasticity in the samples generated from DDPM. However, utilizing deterministic samples from DDIM allows us to not only generate our samples quickly, but also be able to interpolate between two different domains easily.</li> </ol> <p>Therefore, we see that DDIM is a more efficient and effective sampling procedure over DDPM, and <strong>therefore, this is why the authors of the LDM paper use DDIM over DDPM.</strong> In the next and final part of the blog, we will cover conditioning and classifier/classifier-free guidance!</p> <hr> <p><em>Image credits to:</em></p> <ul> <li><a href="https://arxiv.org/pdf/2006.11239.pdf" rel="external nofollow noopener" target="_blank">DDPM Training and Sampling Algorithm</a></li> <li><a href="https://arxiv.org/pdf/2010.02502.pdf" rel="external nofollow noopener" target="_blank">DDIM Forward/Sampling Diagram</a></li> </ul> </article> </div> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2023 Kevin (Won June) Cho. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.8/dist/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js"></script> <script defer src="/assets/js/common.js"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>